<p>20210909</p>
<ul>
    <li><b>깃 명령어 필요없이, vscode github 연동.</b></li>
    <li>깃허브로 계정 생성</li>
    <li>깃허브로 리포트리지 생성</li>
    <li>깃 다운로드</li>
    <li>비주얼 스튜디오 코드 다운로드</li>
    <li>github의 리포지토지와 git의 로컬저장소를 비주얼 스튜디오 코드로 연동하기. [f1> git Clone> 깃허브 리포지토리 URL 복붙]</li>
    <li>깃허브에서 토근을 발급받는다. 아이디, 비밀번호로 로그인하는 게 아니라, 토큰으로 한다. [깃허브>오른쪽 위 프로필>셋팅>개발자셋팅>personal access tokens>크리에이티브 토큰]</li>
    <li>비주얼 스튜디오 코드로 깃허브 커밋. [git icon> (파일 옆) +> (소스 제어 옵션바) v> 커밋메시지아무거나> (오른쪽아래)새로고침 icon]</li>
</ul>

<ul>
    <li><b>mysql</b></li>
    <li>다운로드</li>
    <li>node.js 다운로드</li>
    <li>MySQL 다운로드하기 전 주의사항</li>
        <ul>
            <li>(MySQL다운하기 전에 win+x> y> 이 pc의 이름 바꾸기> 한글이름을 영문이름으로... 한글이름으로 했다가 오류나면 재설치 해야 합니다.)</li>
            <li>(재설치 시, C\programData    (programFiles가 아니다!!!!)    \mySQL를 삭제해야 합니다.)</li>
        </ul>
    <li>MySQL 다운로드</li>
    <ul>
        <li>https://downloads.mysql.com/archives/installer/</li>
        <li>설치는 NEXT 버튼을 계속 클릭하고, 마지막에 root 비밀번호를 잊어서는 안 됩니다.</li>
    </ul>
    <li><b>node.js mysql 예제</b></li>
    <ul>
        <li>터미널</li>
        <li>mysql -u root -p //mysql 커멘드라인</li>
        <li>root 비밀번호</li>
        <li>create database 데이터베이스명; //</li>
        <li>use mydb; //mydb run</li>
        <li>create table 테이블명 (필드명 자료형 필드속성, 반복);</li>
        <ul>
            <li>자료형: varchar 문자열, int 정수 숫자, double 실수 숫자.</li>
            <li>필드속성 : NOT NULL 반드시 입력해야 하는 필드, AUTO_INCREMENT 자동으로 숫자가 증가하게 만든다. PRIMARY KEY 기본 키로 지정한다.</li>
            <li>테이블 생성할 때 표의 형태까지 만드는구나. 나중에 수정하는 방법도 있구나.</li>
            <li>예제)</li>
            <li>creat table bla (</li>
            <li>    id int primary key,</li>
            <li>    name varchar</li>
            <li>) ;</li>
        </ul>
        <li>npm install mysql</li>
        <li>
            //파일명: db_connection.js
            //작성자: 박윤서

            /* createConnection (user, password); */
            const mysql = require ('mysql');

            let client = mysql.createConnection ({
                host: 'localhost',
                user: 'root',
                password: '****,
                database: 'mydb'
            });

            client.connect(); //database run...

            /* query ('sql', (에러를 받는 매개변수, 접속결과를 받는 매개변수, 매개변수)); */
            client.query ('SELECT * from portfolio', (error, results, fields) => {
                if (!error) {
                    console.log(results); //접속결과로 어디가 문제이다를 알 수 있다. 어디가 문제이다를 알려면 에러에 써줘야 한다.
                    console.log(fields);
                } else {
                    console.log(error);
                }
            });
        </li>
    </ul>
</ul>
<ul>
    <li><b>express</b></li>
    <li>애플리케이션 생성</li>
    <ul>
        <li>터미널</li>
        <li>npm install express</li>
        <li>express Helloexpress</li>
        <li>cd Helloexpress</li>
        <li>npm install //package.json</li>
        <li>SET DEBUG=helloexpress:* & npm start //server run</li>
        <li>127.0.0.1:3000</li>
    </ul>
    <li>애플리케이션을 깃허브에 생성할 수 있구나. 원래는 애플리케이션을 생성할 때, 직접 다 쓰고 테스트하면 백날 걸리는데 쉽게 한다.</li>
    <ul>
        <li>git icon > + > v > 커밋메시지아무거나 > 왼쪽 하단 새로고침 버튼.</li>
        <li>[변경된 사항이 1000개 정도 있을텐데, 이거 1000개가 다 해체되서 올라가는 거 아니야?라고 걱정할 필요가 없다. 폴더채로 업로드된다.]</li>
    </ul>
    <li>애플리케이션 디렉토리 설명</li>
    <ul>
        <li>bin 폴더는 프로그램 실행파일이 있고 www 파일을 싱행해서 프레임워크를 실행한다.</li>
        <li>public 폴더는 express 모듈의 static 미들웨어를 사용하여 웹 서버에 로딩하고 자바스크립트, css, 그림파일 등의 리소스 파일을 생성한다.</li>
        <li>routes 폴더는 페이지 라우트와 관련되어 있는 모듈이며 index.js. 파일과 routes 파일이 있다.</li>
        <li>views 폴더는 .ejs(ejs모듈은 표현식을 HTML 형식으로 변환한다.) .jade(jade 모듈은 기본 형식을 html 문자열로 바꿀 수 있는 함수를 생성함)</li>
        <li>app.js는 프로젝트의 중심이 되는 파일이며 package.json 파일은 현재 프로젝트와 관련된 정보와 모듈을 설치하는데 필요한 내용을 담고 있다.</li>
    </ul>
    <li>node.js mysql express 예제</li>
    <li>
        const mysql = require('mysql');
        const express = require ('express');
        const ejs = require ('ejs');
        const fs = require ('fs');

        let client = mysql.createConnection ({
            host: 'localhost',
            user: 'root',
            password: '****,
            database: 'mydb'
        }); //mysql 객체 생성

        client.connect(); //database run..

        let app = express(); // 익스프레스 객체 생성

        /*
        //라우터 기본, 원형
        app.get('/', function (request, response) {
            response.send ('index.html'); //다양한 응답을 전송
        });

        //미들웨어 함수란?
        //응용 프로그램의 요청&응답 주기에 함수를 액세스 할 수 있는 함수입니다.
        //그리고 express 라우터의 함수로 호출될 때 현재 미들웨어에 성공하는 미들웨어를 실행합니다.
        //('미들웨어 함수가 적용되는 경로'. 미들웨어 기능(http요청인수> http응답인수> 콜백인수) {} );
        app.get('/', function(request, response, next ) {
            response.send('Hello World!');
         });

        //템플릿 엔진 모듈이란?
        //특정 형식의 문자열 (<% 자바스크립트 %> 또는 <%= 출력문 %>)을 HTML형식으로 변환한다.
        //.render (str, data); //특정 형식의 문자열을 html 문자열로 변경해 주는 메소드.
        let middle = app.get('/', function(request, response, next ) {
            let output = response.render("<%= 5+7 %>");
            response.send(output);
        });

        // fs로 ejs페이지 불러오기
        app.get ('/', function(request, response, next ) {
            fs.readFile ('./views/webdesign_portfolio.html', 'utf-8', (error, data) => {
                    response.send (data);
                });
            });
        });

        // mysql 데이터 조회
        app.get ('/', function(request, response, next ) {
            client.query ('SELECT * from portfolio', (error, results, fields) => { /
                    response.send (result);
            });
        });
        */

        app.get ('/', function(request, response, next ) {
            fs.readFile ('./views/webdesign_portfolio.html', 'utf-8', (error, data) => { //ejs페이지 불러오기
                client.query ('SELECT * from portfolio', (error, results, fields) => { //데이터 조회
                    let output = ejs.render (data, {
                        data: results
                    }); //<% %>을 html로 변환. ejs페이지 불러오기한 문자열, 데이터 조회한 데이터.
                    response.send (output); //웹서버에 전송
                } );
            });
        });

        app.listen (3000); //server run...
    </li>
    <li>
        <!-- 파일명: webdesign_portfolio.html -->
        <% data.forEach (function (item, index) { %>
            <%= item.id %>
            <%= item.name %>
        <% }) %>
    </li>
</ul>
<ul>
    <li>웹서버와 깃허브</li>
</ul>
<ul>
    <li><b>CRUD</b></li>
    <ul>
        <li>CRUD는 DB의 가장 기본적인 기능입니다.</li>
        <li>Create, Read, Update, Delete라고 해서 CRUD라고 합니다.</li>
        <li>CRUD를 만들기 위해서 express 모듈, body parser 모듈, ejs 모듈, MySQL 모듈을 설치를 합니다.</li>
        <ul>
            <li>npm install express</li>
            <li>npm install body parser</li>
            <li>npm install ejs</li>
            <li>npm install mysql</li>
        </ul>
        <li>데이터 조회</li>
        <ul>
            <li>SELECT 필드, 필드 FROM 테이블 형식으로 퀴리문을 사용한다.</li>
            <li>SELECT 필드, 필드 FROM 테이블 where 필드='필드값'; 형식으로 조건검사의 퀴리문을 사용한다.(연산자사용, Like)</li>
            <li>SELECT 필드, 필드 FROM 테이블 order asc(오름차순) or desc(내림차순);으로 데이터 정렬을 사용한다.</li>
            <li>SELECT 필드, 필드 FROM 테이블 limit 2 or 2,2; 를 이용하여 상위데이터를 선택한다. 2,2는 2묶음의 두 번째. //게시판 페이징할 때, 사용함.</li>
            <li>
                const fs = require('fs');
                const ejs = require('ejs');
                const express = require('express');
                const mysql = require('mysql');

                /* createConnection (user, password); */
                let client = mysql.createConnection ({
                    user: 'root',
                    password: '****,
                    database: '****'
                });

                /* 웹서버 생성 */
                let app = express();

                app.use(bodyParser.urlencoded( { extended: false} )); //post를 사용하기 때문에 인코딩을 해야한다.

                /* db로 접속 .get 메소드를 사용한다. */
                app.get('/', (request, response) )=> { //db로 접속해서 데이터를 가져와서, 아래 파일에 데이터를 뿌려버린다.
                    fs.readFile('게시판명.html', 'utf-8', (error, data) => {
                        response.send(ejs.render (data, { //ejs가 표현식을 도와줌.
                            data: result
                        }));
                    } );
                } );
                /*
                게시판명.html에서 body에 테이블 시작하는데에 <%  data.forEach (function (item, index {%> 으로 표현식을 열어주고?
                <%= item.필드명 %>
                <% ) }; %>
                html에서 데이터를 출력할 수 있다^!^
                %/
            </li>
        </ul>
        <li>데이터 저장</li>
        <ul>
            <li>INSERT INTO (필드,필드) VALUE (데이터, 데이터) 형식으로 퀴리문을 작성한다.</li>
            <li>
                app.get('/insert', (request, response) => {
                    fs.readFile('게시판명.html'm 'utf-8', (error, data) => {
                        response.end(data);
                    } );
                } );
                app.post('/insert', (request, response) => {
                    let body = request.body;
                    client.query('INSERT INTO 테입ㄹ명 (필드) VALUE (?, ?, ?')'', [body.필드명]
                } );
                /%
                게시판.html에서
                form method="post"
                ... input type="text" name="필드명"
                ... input type="submit"
                %/
            </li>
        </ul>
        <li>데이터 삭제</li>
        <ul>
            <li>delete from 테이블명 where 필드명(키)="필드값"; //조건으로 프라이머 키를 사용하지 않으면 전체 데이터가 삭제되니, 주의하기 바란다.</li>
            <li>
                app.get('/delete/:id', (request, response) => { // /:id를 하는 이유는 전체 다 삭제하지 않기 위해서
                    client.query('DELETE FROM 테이블명 WHERE 필드명(key)=?', [request.params.id], () => { //필드값대신 클릭한 필드값을 지우기 위해서 [ㅇㅇ]을 사용함.
                        () => {
                            response.radirect('/');
                        } );
                    });
                } );
            </li>
        </ul>
        <li>데이터 수정</li>
        <ul>
            <li>update 테이블명 set 필드명="필드값" where 필드명(key)="필드값"//조건으로 프라이머 키를 사용하지 않으면 전체 데이터가 변경되니, 주의하기 바란다.</li>
            <li>
                app.get('/edit/:id', (request, response) => {
                    fs.readFile('게시판명.html'm 'utf-8', (error, data) => {
                        
                        client.query('UPDATE 테입ㄹ명 (필드) VALUE (?, ?, ?')'', [body.필드명], (error, result)  => {
                            response.send(ejs.render(data, {
                            data: result[0]
                        } ) );
                    } );
                } );
                app.post('/insert', (request, response) => {
                    let body = request.body;
                    
                } );
                /%
                게시판.html에서
                form method="post"
                ... input type="text" name="필드명" value<%= data.id %> disable/>
                ... input type="submit"
                %/
                app.post('/edit/:id', (request, response) => {
                    let body = request.body;
                
                    client.query('UPDATE 테입ㄹ명 SET 필드=?, 필드=? VALUES (?, ?), [body.필드, body.필드], (error, result) => {
                    } );
                } );
            </li>
        </ul>
    </ul>
</ul>